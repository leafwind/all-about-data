# 積非成是的資料，與其相對應的龐大代價

####

---

引用我同事的名言：

```
爛 code 在經過長時間的演化之後，就會變成穩定的爛 code：不只爛，而且比任何試圖改進的版本穩定。
```

不只爛 code，爛的資料設計也是。

中文有類似的成語叫做「積非成是」，英文也有：

```
If two wrongs don’t make a right, try three — Laurence J. Peter
```

一旦髒的資料在 upstream 被產生出來，downstream 會發生什麼事？
有幾種可能：

1. 試著幫忙做清理
2. 沒發現，一直用爛掉的資料做錯誤的演算法
3. 將 code 改成「錯誤」的寫法去配合錯誤的資料設計

第一種情況會造成技術債，所有 downstream 都會試著做類似的事情，但卻不完全一樣！

輕者線性增加開發時間（重工）；重者增加系統複雜度，埋下更多地雷（你的清理跟我的清理不一樣，結果兩個系統接不起來）

而後者所增加的隱性開發成本，就是非線性的了。

第二種情況很簡單，演算法改善 5% 歡天喜地，卻被錯誤的資料 downgrade -80%

第三種情況會讓你非常難脫離「爛設計」，因為一旦錯誤資料被設計出來，他就必須存在以維持系統穩定。

舉個例子來說：

```
{
    "timestamp1": "1486656000”,
    "timestamp2": 1532966400,
    "enabled": "false"
}
```

第一種情況，有人就會試著去把 "1486656000" 讓他變成 1486656000(int)，但也有可能另一個人轉成 1486656000.0 (float)，第三個人不知道，就直接用（變成下一種情況）

第二種情況就會直覺以為 timestamp1 要存 int，沒有確認過就直接拿去比對時間戳記，有時候碰巧對，但是因為沒有測試，所以等到出大包才會有人發現。

第三種，看到其他欄位都是字串，以為字串才是對的；或者自己也有壞習慣用字串存時間戳記，於是整個程式的邏輯就變成字串跟字串比大小。

非常要命的是在這個欄位，都是長度為 10 的數字字串，所以不管有沒有轉成 int 去比較，結果會是一樣的！於是 code 就隱含了這個「假設」，但下一個人用到這份 code 的時候沒有仔細檢查資料，就直接把這個邏輯用在其他「應該要是 int 卻存成 string」的欄位，像這樣：

```
>>> 100 > 2
True
>>> "100" < "2"
False
```

這是一個很愚蠢的例子，當我們在寫固定輸入的程式，這很難發生

除了必須事先想像各種不可思議的 test case 之外，最麻煩的是牽涉到商業邏輯：或許有時候把零加進去平均是合理的，但有時候則應該用 null 避免把平均拉低，而你不知道使用者對這些行為的期待會是什麼（除非你在維護一個很穩定、已經被眾人普遍接受，且很少增加功能的產品）

```
切記：上游做太少，下游就一定會做太過，讓上游的任何修正都窒礙難行
```

## 錯誤的設計

### 命名 confuse

一筆名為 timestamp 的資料，存的其實是 ISO 8601 string type2017–06–28T01:05:35

## 沒想清楚的意外

有時候不一定是錯誤的設計，而是設計的時候沒有想清楚資料會被如何使用。

### 連內容都不知道就指定 default value 可以很危險

常見的 default value 有三種：null, empty, zero

看到型態是 int 就給他 default = 0，乍看有道理，但如果這個欄位湊巧就是經緯度的時候，這筆資料的意義就從「預設值」或「我不知道」而是「位於非洲的幾內亞灣」

那給 null 總行了吧？如果這個欄位湊巧是「」


又如果 data consumer 根本不知道資料裡面有幾種 default value，情況就會更混亂

這些資料如果是給人來看，大部分問題還不嚴重

但若是給機器看，這個 feature 就會被當做是非洲的資料（也就是「弄髒」了）